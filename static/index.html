<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ESP32-CAM Viewer (Manual Refresh)</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
    #cam { max-width: 90%; border: 1px solid #ccc; background:#f8f8f8; }
    #controls { margin-top: 12px; }
    #status { margin-top:8px; color:#666; font-size:0.9em; }
    #spinner { display:inline-block; width:16px; height:16px; vertical-align:middle; margin-right:6px; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <h1>ESP32-CAM Viewer</h1>

  <div>
    <img id="cam" src="/latest.jpg" alt="camera image" />
  </div>

  <div id="controls">
    <button id="refreshBtn">画像を更新</button>
    <label style="margin-left:12px;">
      自動更新
      <input type="checkbox" id="autoToggle" />
    </label>
    <label style="margin-left:8px;">
      間隔(秒)
      <input id="intervalSec" type="number" value="10" min="1" style="width:60px;" />
    </label>
  </div>

  <div id="status">
    <span id="spinner" class="hidden">⏳</span>
    <span id="msg">最後の更新: 未更新</span>
  </div>

  <script>
    const img = document.getElementById("cam");
    const btn = document.getElementById("refreshBtn");
    const autoToggle = document.getElementById("autoToggle");
    const intervalSec = document.getElementById("intervalSec");
    const msg = document.getElementById("msg");
    const spinner = document.getElementById("spinner");

    function showStatus(text) {
      msg.textContent = text;
    }

    async function refreshImage() {
      spinner.classList.remove("hidden");
      // キャッシュ回避のためタイムスタンプを付与
      const ts = Date.now();
      const url = "/latest.jpg?t=" + ts;
      // 先にフェッチして 200 を確認してから img.src にセット（真っ白/フラッシュ対策）
      try {
        const resp = await fetch(url, { method: "GET", cache: "no-store" });
        if (!resp.ok) {
          showStatus("更新失敗: サーバーに画像がありません (" + resp.status + ")");
          spinner.classList.add("hidden");
          return;
        }
        // ブロブを得て、オブジェクトURL を作って img.src にセット
        const blob = await resp.blob();
        const objectUrl = URL.createObjectURL(blob);
        // 画像が読み込まれてから古い object URL を解放するためのハンドラ
        img.onload = () => {
          // 前のオブジェクトURL があれば解放（メモリ対策）
          if (img._lastObjectUrl) {
            URL.revokeObjectURL(img._lastObjectUrl);
          }
          img._lastObjectUrl = objectUrl;
          showStatus("最後の更新: " + (new Date()).toLocaleTimeString());
          spinner.classList.add("hidden");
        };
        img.onerror = () => {
          showStatus("画像読み込みエラー");
          spinner.classList.add("hidden");
        };
        img.src = objectUrl;
      } catch (e) {
        showStatus("通信エラー: " + e.message);
        spinner.classList.add("hidden");
      }
    }

    btn.addEventListener("click", refreshImage);

    // 自動更新タイマー
    let timer = null;
    autoToggle.addEventListener("change", () => {
      if (autoToggle.checked) {
        const sec = Math.max(1, parseInt(intervalSec.value || "10", 10));
        timer = setInterval(refreshImage, sec * 1000);
        refreshImage();
      } else {
        if (timer) { clearInterval(timer); timer = null; }
      }
    });

    // 初回は手動更新待ち（既に表示がある場合はそれを維持）
    showStatus("最後の更新: ページ読み込み時の画像を表示中");
  </script>
</body>
</html>
